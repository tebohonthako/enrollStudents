/**
 * @license
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://raw.githubusercontent.com/l-lin/angular-datatables/master/LICENSE
 */
import { Directive, ElementRef, Input, Renderer2, ViewContainerRef } from '@angular/core';
import { Subject } from 'rxjs';
import * as i0 from "@angular/core";
export class DataTableDirective {
    constructor(el, vcr, renderer) {
        this.el = el;
        this.vcr = vcr;
        this.renderer = renderer;
        /**
         * The DataTable option you pass to configure your table.
         */
        this.dtOptions = {};
    }
    ngOnInit() {
        if (this.dtTrigger) {
            this.dtTrigger.subscribe((options) => {
                this.displayTable(options);
            });
        }
        else {
            this.displayTable(null);
        }
    }
    ngOnDestroy() {
        if (this.dtTrigger) {
            this.dtTrigger.unsubscribe();
        }
        if (this.dt) {
            this.dt.destroy(true);
        }
    }
    displayTable(dtOptions) {
        // assign new options if provided
        if (dtOptions) {
            this.dtOptions = dtOptions;
        }
        this.dtInstance = new Promise((resolve, reject) => {
            Promise.resolve(this.dtOptions).then(resolvedDTOptions => {
                // validate object
                const isTableEmpty = Object.keys(resolvedDTOptions).length === 0 && $('tbody tr', this.el.nativeElement).length === 0;
                if (isTableEmpty) {
                    reject('Both the table and dtOptions cannot be empty');
                    return;
                }
                // Set a column unique
                if (resolvedDTOptions.columns) {
                    resolvedDTOptions.columns.forEach(col => {
                        if ((col.id ?? '').trim() === '') {
                            col.id = this.getColumnUniqueId();
                        }
                    });
                }
                // Using setTimeout as a "hack" to be "part" of NgZone
                setTimeout(() => {
                    // Assign DT properties here
                    let options = {
                        rowCallback: (row, data, index) => {
                            if (resolvedDTOptions.columns) {
                                const columns = resolvedDTOptions.columns;
                                this.applyNgPipeTransform(row, columns);
                                this.applyNgRefTemplate(row, columns, data);
                            }
                            // run user specified row callback if provided.
                            if (resolvedDTOptions.rowCallback) {
                                resolvedDTOptions.rowCallback(row, data, index);
                            }
                        }
                    };
                    // merge user's config with ours
                    options = Object.assign({}, resolvedDTOptions, options);
                    this.dt = $(this.el.nativeElement).DataTable(options);
                    resolve(this.dt);
                });
            });
        });
    }
    applyNgPipeTransform(row, columns) {
        // Filter columns with pipe declared
        const colsWithPipe = columns.filter(x => x.ngPipeInstance && !x.ngTemplateRef);
        colsWithPipe.forEach(el => {
            const pipe = el.ngPipeInstance;
            const pipeArgs = el.ngPipeArgs || [];
            // find index of column using `data` attr
            const i = columns.filter(c => c.visible !== false).findIndex(e => e.id === el.id);
            // get <td> element which holds data using index
            const rowFromCol = row.childNodes.item(i);
            // Transform data with Pipe and PipeArgs
            const rowVal = $(rowFromCol).text();
            const rowValAfter = pipe.transform(rowVal, ...pipeArgs);
            // Apply transformed string to <td>
            $(rowFromCol).text(rowValAfter);
        });
    }
    applyNgRefTemplate(row, columns, data) {
        // Filter columns using `ngTemplateRef`
        const colsWithTemplate = columns.filter(x => x.ngTemplateRef && !x.ngPipeInstance);
        colsWithTemplate.forEach(el => {
            const { ref, context } = el.ngTemplateRef;
            // get <td> element which holds data using index
            const i = columns.filter(c => c.visible !== false).findIndex(e => e.id === el.id);
            const cellFromIndex = row.childNodes.item(i);
            // reset cell before applying transform
            $(cellFromIndex).html('');
            // render onto DOM
            // finalize context to be sent to user
            const _context = Object.assign({}, context, context?.userData, {
                adtData: data
            });
            const instance = this.vcr.createEmbeddedView(ref, _context);
            this.renderer.appendChild(cellFromIndex, instance.rootNodes[0]);
        });
    }
    getColumnUniqueId() {
        let result = '';
        const characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
        for (let i = 0; i < 6; i++) {
            const randomIndex = Math.floor(Math.random() * characters.length);
            result += characters.charAt(randomIndex);
        }
        return result.trim();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "18.0.5", ngImport: i0, type: DataTableDirective, deps: [{ token: i0.ElementRef }, { token: i0.ViewContainerRef }, { token: i0.Renderer2 }], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "18.0.5", type: DataTableDirective, selector: "[datatable]", inputs: { dtOptions: "dtOptions", dtTrigger: "dtTrigger" }, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "18.0.5", ngImport: i0, type: DataTableDirective, decorators: [{
            type: Directive,
            args: [{
                    selector: '[datatable]'
                }]
        }], ctorParameters: () => [{ type: i0.ElementRef }, { type: i0.ViewContainerRef }, { type: i0.Renderer2 }], propDecorators: { dtOptions: [{
                type: Input
            }], dtTrigger: [{
                type: Input
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYW5ndWxhci1kYXRhdGFibGVzLmRpcmVjdGl2ZS5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL2xpYi9zcmMvYW5ndWxhci1kYXRhdGFibGVzLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7R0FLRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFBcUIsU0FBUyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzdHLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBTy9CLE1BQU0sT0FBTyxrQkFBa0I7SUF5QjdCLFlBQ1UsRUFBYyxFQUNkLEdBQXFCLEVBQ3JCLFFBQW1CO1FBRm5CLE9BQUUsR0FBRixFQUFFLENBQVk7UUFDZCxRQUFHLEdBQUgsR0FBRyxDQUFrQjtRQUNyQixhQUFRLEdBQVIsUUFBUSxDQUFXO1FBM0I3Qjs7V0FFRztRQUVILGNBQVMsR0FBZ0IsRUFBRSxDQUFDO0lBd0J4QixDQUFDO0lBRUwsUUFBUTtRQUNOLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO1lBQ25CLElBQUksQ0FBQyxTQUFTLENBQUMsU0FBUyxDQUFDLENBQUMsT0FBTyxFQUFFLEVBQUU7Z0JBQ25DLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxDQUFDLENBQUM7WUFDN0IsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDO2FBQU0sQ0FBQztZQUNOLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDMUIsQ0FBQztJQUNILENBQUM7SUFFRCxXQUFXO1FBQ1QsSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7WUFDbkIsSUFBSSxDQUFDLFNBQVMsQ0FBQyxXQUFXLEVBQUUsQ0FBQztRQUMvQixDQUFDO1FBQ0QsSUFBSSxJQUFJLENBQUMsRUFBRSxFQUFFLENBQUM7WUFDWixJQUFJLENBQUMsRUFBRSxDQUFDLE9BQU8sQ0FB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LE1BQU0sSUFBSSxVQUFVLENBQUMsTUFBTSxDQUFDLFdBQVcsQ0FBQyxDQUFDO1FBQzNDLENBQUM7UUFFRCxPQUFPLE1BQU0sQ0FBQyxJQUFJLEVBQUUsQ0FBQztJQUN2QixDQUFDOzhHQW5KVSxrQkFBa0I7a0dBQWxCLGtCQUFrQjs7MkZBQWxCLGtCQUFrQjtrQkFIOUIsU0FBUzttQkFBQztvQkFDVCxRQUFRLEVBQUUsYUFBYTtpQkFDeEI7c0lBTUMsU0FBUztzQkFEUixLQUFLO2dCQVFOLFNBQVM7c0JBRFIsS0FBSyIsInNvdXJjZXNDb250ZW50IjpbIi8qKlxuICogQGxpY2Vuc2VcbiAqXG4gKiBVc2Ugb2YgdGhpcyBzb3VyY2UgY29kZSBpcyBnb3Zlcm5lZCBieSBhbiBNSVQtc3R5bGUgbGljZW5zZSB0aGF0IGNhbiBiZVxuICogZm91bmQgaW4gdGhlIExJQ0VOU0UgZmlsZSBhdCBodHRwczovL3Jhdy5naXRodWJ1c2VyY29udGVudC5jb20vbC1saW4vYW5ndWxhci1kYXRhdGFibGVzL21hc3Rlci9MSUNFTlNFXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFbGVtZW50UmVmLCBJbnB1dCwgT25EZXN0cm95LCBPbkluaXQsIFJlbmRlcmVyMiwgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgQURUU2V0dGluZ3MsIEFEVENvbHVtbnMgfSBmcm9tICcuL21vZGVscy9zZXR0aW5ncyc7XG5pbXBvcnQgeyBBcGkgfSBmcm9tICdkYXRhdGFibGVzLm5ldCc7XG5cbkBEaXJlY3RpdmUoe1xuICBzZWxlY3RvcjogJ1tkYXRhdGFibGVdJ1xufSlcbmV4cG9ydCBjbGFzcyBEYXRhVGFibGVEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkRlc3Ryb3ksIE9uSW5pdCB7XG4gIC8qKlxuICAgKiBUaGUgRGF0YVRhYmxlIG9wdGlvbiB5b3UgcGFzcyB0byBjb25maWd1cmUgeW91ciB0YWJsZS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGR0T3B0aW9uczogQURUU2V0dGluZ3MgPSB7fTtcblxuICAvKipcbiAgICogVGhpcyB0cmlnZ2VyIGlzIHVzZWQgaWYgb25lIHdhbnRzIHRvIHRyaWdnZXIgbWFudWFsbHkgdGhlIERUIHJlbmRlcmluZ1xuICAgKiBVc2VmdWwgd2hlbiByZW5kZXJpbmcgYW5ndWxhciByZW5kZXJlZCBET01cbiAgICovXG4gIEBJbnB1dCgpXG4gIGR0VHJpZ2dlciE6IFN1YmplY3Q8QURUU2V0dGluZ3M+O1xuXG4gIC8qKlxuICAgKiBUaGUgRGF0YVRhYmxlIGluc3RhbmNlIGJ1aWx0IGJ5IHRoZSBqUXVlcnkgbGlicmFyeSBbRGF0YVRhYmxlc10oZGF0YXRhYmxlcy5uZXQpLlxuICAgKlxuICAgKiBJdCdzIHBvc3NpYmxlIHRvIGV4ZWN1dGUgdGhlIFtEYXRhVGFibGVzIEFQSXNdKGh0dHBzOi8vZGF0YXRhYmxlcy5uZXQvcmVmZXJlbmNlL2FwaS8pIHdpdGhcbiAgICogdGhpcyB2YXJpYWJsZS5cbiAgICovXG4gIGR0SW5zdGFuY2UhOiBQcm9taXNlPEFwaT47XG5cbiAgLy8gT25seSB1c2VkIGZvciBkZXN0cm95aW5nIHRoZSB0YWJsZSB3aGVuIGRlc3Ryb3lpbmcgdGhpcyBkaXJlY3RpdmVcbiAgcHJpdmF0ZSBkdCE6IEFwaTtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIGVsOiBFbGVtZW50UmVmLFxuICAgIHByaXZhdGUgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIHByaXZhdGUgcmVuZGVyZXI6IFJlbmRlcmVyMlxuICApIHsgfVxuXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmR0VHJpZ2dlcikge1xuICAgICAgdGhpcy5kdFRyaWdnZXIuc3Vic2NyaWJlKChvcHRpb25zKSA9PiB7XG4gICAgICAgIHRoaXMuZGlzcGxheVRhYmxlKG9wdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGlzcGxheVRhYmxlKG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIG5nT25EZXN0cm95KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmR0VHJpZ2dlcikge1xuICAgICAgdGhpcy5kdFRyaWdnZXIudW5zdWJzY3JpYmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuZHQpIHtcbiAgICAgIHRoaXMuZHQuZGVzdHJveSh0cnVlKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGRpc3BsYXlUYWJsZShkdE9wdGlvbnM6IEFEVFNldHRpbmdzIHwgbnVsbCk6IHZvaWQge1xuICAgIC8vIGFzc2lnbiBuZXcgb3B0aW9ucyBpZiBwcm92aWRlZFxuICAgIGlmIChkdE9wdGlvbnMpIHtcbiAgICAgIHRoaXMuZHRPcHRpb25zID0gZHRPcHRpb25zO1xuICAgIH1cbiAgICB0aGlzLmR0SW5zdGFuY2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBQcm9taXNlLnJlc29sdmUodGhpcy5kdE9wdGlvbnMpLnRoZW4ocmVzb2x2ZWREVE9wdGlvbnMgPT4ge1xuICAgICAgICAvLyB2YWxpZGF0ZSBvYmplY3RcbiAgICAgICAgY29uc3QgaXNUYWJsZUVtcHR5ID0gT2JqZWN0LmtleXMocmVzb2x2ZWREVE9wdGlvbnMpLmxlbmd0aCA9PT0gMCAmJiAkKCd0Ym9keSB0cicsIHRoaXMuZWwubmF0aXZlRWxlbWVudCkubGVuZ3RoID09PSAwO1xuICAgICAgICBpZiAoaXNUYWJsZUVtcHR5KSB7XG4gICAgICAgICAgcmVqZWN0KCdCb3RoIHRoZSB0YWJsZSBhbmQgZHRPcHRpb25zIGNhbm5vdCBiZSBlbXB0eScpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNldCBhIGNvbHVtbiB1bmlxdWVcbiAgICAgICAgaWYgKHJlc29sdmVkRFRPcHRpb25zLmNvbHVtbnMpIHtcbiAgICAgICAgICByZXNvbHZlZERUT3B0aW9ucy5jb2x1bW5zLmZvckVhY2goY29sID0+IHtcbiAgICAgICAgICAgIGlmICgoY29sLmlkID8/ICcnKS50cmltKCkgPT09ICcnKSB7XG4gICAgICAgICAgICAgIGNvbC5pZCA9IHRoaXMuZ2V0Q29sdW1uVW5pcXVlSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFVzaW5nIHNldFRpbWVvdXQgYXMgYSBcImhhY2tcIiB0byBiZSBcInBhcnRcIiBvZiBOZ1pvbmVcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgLy8gQXNzaWduIERUIHByb3BlcnRpZXMgaGVyZVxuICAgICAgICAgIGxldCBvcHRpb25zOiBBRFRTZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIHJvd0NhbGxiYWNrOiAocm93LCBkYXRhLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgICBpZiAocmVzb2x2ZWREVE9wdGlvbnMuY29sdW1ucykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbHVtbnMgPSByZXNvbHZlZERUT3B0aW9ucy5jb2x1bW5zO1xuICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlOZ1BpcGVUcmFuc2Zvcm0ocm93LCBjb2x1bW5zKTtcbiAgICAgICAgICAgICAgICB0aGlzLmFwcGx5TmdSZWZUZW1wbGF0ZShyb3csIGNvbHVtbnMsIGRhdGEpO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgLy8gcnVuIHVzZXIgc3BlY2lmaWVkIHJvdyBjYWxsYmFjayBpZiBwcm92aWRlZC5cbiAgICAgICAgICAgICAgaWYgKHJlc29sdmVkRFRPcHRpb25zLnJvd0NhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZWREVE9wdGlvbnMucm93Q2FsbGJhY2socm93LCBkYXRhLCBpbmRleCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIC8vIG1lcmdlIHVzZXIncyBjb25maWcgd2l0aCBvdXJzXG4gICAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIHJlc29sdmVkRFRPcHRpb25zLCBvcHRpb25zKTtcbiAgICAgICAgICB0aGlzLmR0ID0gJCh0aGlzLmVsLm5hdGl2ZUVsZW1lbnQpLkRhdGFUYWJsZShvcHRpb25zKTtcbiAgICAgICAgICByZXNvbHZlKHRoaXMuZHQpO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBhcHBseU5nUGlwZVRyYW5zZm9ybShyb3c6IE5vZGUsIGNvbHVtbnM6IEFEVENvbHVtbnNbXSk6IHZvaWQge1xuICAgIC8vIEZpbHRlciBjb2x1bW5zIHdpdGggcGlwZSBkZWNsYXJlZFxuICAgIGNvbnN0IGNvbHNXaXRoUGlwZSA9IGNvbHVtbnMuZmlsdGVyKHggPT4geC5uZ1BpcGVJbnN0YW5jZSAmJiAheC5uZ1RlbXBsYXRlUmVmKTtcbiAgICBjb2xzV2l0aFBpcGUuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCBwaXBlID0gZWwubmdQaXBlSW5zdGFuY2UhO1xuICAgICAgY29uc3QgcGlwZUFyZ3MgPSBlbC5uZ1BpcGVBcmdzIHx8IFtdO1xuICAgICAgLy8gZmluZCBpbmRleCBvZiBjb2x1bW4gdXNpbmcgYGRhdGFgIGF0dHJcbiAgICAgIGNvbnN0IGkgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZSAhPT0gZmFsc2UpLmZpbmRJbmRleChlID0+IGUuaWQgPT09IGVsLmlkKTtcbiAgICAgIC8vIGdldCA8dGQ+IGVsZW1lbnQgd2hpY2ggaG9sZHMgZGF0YSB1c2luZyBpbmRleFxuICAgICAgY29uc3Qgcm93RnJvbUNvbCA9IHJvdy5jaGlsZE5vZGVzLml0ZW0oaSk7XG4gICAgICAvLyBUcmFuc2Zvcm0gZGF0YSB3aXRoIFBpcGUgYW5kIFBpcGVBcmdzXG4gICAgICBjb25zdCByb3dWYWwgPSAkKHJvd0Zyb21Db2wpLnRleHQoKTtcbiAgICAgIGNvbnN0IHJvd1ZhbEFmdGVyID0gcGlwZS50cmFuc2Zvcm0ocm93VmFsLCAuLi5waXBlQXJncyk7XG4gICAgICAvLyBBcHBseSB0cmFuc2Zvcm1lZCBzdHJpbmcgdG8gPHRkPlxuICAgICAgJChyb3dGcm9tQ29sKS50ZXh0KHJvd1ZhbEFmdGVyKTtcbiAgICB9KTtcbiAgfVxuXG4gIHByaXZhdGUgYXBwbHlOZ1JlZlRlbXBsYXRlKHJvdzogTm9kZSwgY29sdW1uczogQURUQ29sdW1uc1tdLCBkYXRhOiBPYmplY3QpOiB2b2lkIHtcbiAgICAvLyBGaWx0ZXIgY29sdW1ucyB1c2luZyBgbmdUZW1wbGF0ZVJlZmBcbiAgICBjb25zdCBjb2xzV2l0aFRlbXBsYXRlID0gY29sdW1ucy5maWx0ZXIoeCA9PiB4Lm5nVGVtcGxhdGVSZWYgJiYgIXgubmdQaXBlSW5zdGFuY2UpO1xuICAgIGNvbHNXaXRoVGVtcGxhdGUuZm9yRWFjaChlbCA9PiB7XG4gICAgICBjb25zdCB7IHJlZiwgY29udGV4dCB9ID0gZWwubmdUZW1wbGF0ZVJlZiE7XG4gICAgICAvLyBnZXQgPHRkPiBlbGVtZW50IHdoaWNoIGhvbGRzIGRhdGEgdXNpbmcgaW5kZXhcbiAgICAgIGNvbnN0IGkgPSBjb2x1bW5zLmZpbHRlcihjID0+IGMudmlzaWJsZSAhPT0gZmFsc2UpLmZpbmRJbmRleChlID0+IGUuaWQgPT09IGVsLmlkKTtcbiAgICAgIGNvbnN0IGNlbGxGcm9tSW5kZXggPSByb3cuY2hpbGROb2Rlcy5pdGVtKGkpO1xuICAgICAgLy8gcmVzZXQgY2VsbCBiZWZvcmUgYXBwbHlpbmcgdHJhbnNmb3JtXG4gICAgICAkKGNlbGxGcm9tSW5kZXgpLmh0bWwoJycpO1xuICAgICAgLy8gcmVuZGVyIG9udG8gRE9NXG4gICAgICAvLyBmaW5hbGl6ZSBjb250ZXh0IHRvIGJlIHNlbnQgdG8gdXNlclxuICAgICAgY29uc3QgX2NvbnRleHQgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LCBjb250ZXh0Py51c2VyRGF0YSwge1xuICAgICAgICBhZHREYXRhOiBkYXRhXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gdGhpcy52Y3IuY3JlYXRlRW1iZWRkZWRWaWV3KHJlZiwgX2NvbnRleHQpO1xuICAgICAgdGhpcy5yZW5kZXJlci5hcHBlbmRDaGlsZChjZWxsRnJvbUluZGV4LCBpbnN0YW5jZS5yb290Tm9kZXNbMF0pO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBnZXRDb2x1bW5VbmlxdWVJZCgpOiBzdHJpbmcge1xuICAgIGxldCByZXN1bHQgPSAnJztcbiAgICBjb25zdCBjaGFyYWN0ZXJzID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5JztcblxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICBjb25zdCByYW5kb21JbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNoYXJhY3RlcnMubGVuZ3RoKTtcbiAgICAgIHJlc3VsdCArPSBjaGFyYWN0ZXJzLmNoYXJBdChyYW5kb21JbmRleCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gIH1cblxufVxuIl19